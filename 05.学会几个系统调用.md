# 学会几个系统调用

## 进程管理
1. Linux创建进程的系统调用叫**fork**，中文叫"分支"
要创建一个新进程，需要一个老的进程调用fork来实现
老进程叫父进程(Parent Process)，新进程叫子进程(Child Process)
2. 父进程要关心子进程的运行情况，毕竟这是自己身上掉下的肉。有个系统调用**waitpid**，父进程可以调用它，将子进程号作为参数传给他，这样父进程就知道子进程运行完了没，成功与否

## 内存管理
1. 在操作系统中，每个进程都有自己的内存，互相之间不干扰，有独立的进程内存空间
2. 对于进程的内存空间来讲，放程序代码的这部分，我们称为**代码段**(Code Segment)，对于进程的内存空间来讲，放进程运行中产生数据的部分，我们称为**数据段**(Data Segment)
3. 一个进程的内存空间是很大的，32位的是4G，64位的就更大了，不可能有这么多物理内存，所以进程自己不用的部分就不用管，只有进程要去使用内存的时候，才会使用管理的系统调用来登记
4. 两个在堆(Heap)里面分配内存的系统调用，**brk**和**mmap**，当分配内存比较小的时候使用brk，会和原来的堆的数据连在一起，当分配的内存比较的时候会使用mmap，会重新划分一块区域

## 文件管理
1. 对于文件的操作，下面这六个系统调用是最重要的
   * 对于已经有的文件，可以使用**open**打开这个文件，**close**关闭这个文件
   * 对于没有的文件，可以使用**creat**创建文件
   * 打开文件以后，可以使用**lseek**跳到文件的某个位置
   * 可以对文件的内容进行读写，读的系统调用是**read**和**write**
2. Linux里有一个特点，那就是**一切皆文件**，每一个文件Linux都会分配一个**文件描述符**(File Descriptor)，这是一个整数。有了个文件描述符，我们就可以使用系统调用，查看或者干预进程运行的方方面面

## 信号处理(异常处理)
1. 用户进程通过**kill**函数，将一个用户信号发给另一个进程
2. 对于一些不严重的信号可以忽略但是像 SIGKILL（用于终止一个进程的信号）和 SIGS（用于中止一个进程的信号）是不能忽略的。可以通过**sigaction**系统调用注册一个信号处理函数

## 进程间通信
1. 发一个消息，不需要很长的数据，这种方式成为**消息队列**(Message Queue)，这个消息队列是在内核里面的，我们可以通过**msgget**创建一个新的队列， **msgsend**发送信息到队列，而消息接收方可以使用msgrcv从队列中取消息。
2. 当交互的信息比较大的时候，可以使用**共享内存**的方式，这样数据就不用拷贝来拷贝去了这时候，我们可以通过**shmget**创建一个共享内存块，通过**shmat**将共享内存映射到自己的内存空间，然后就可以读写了

## 网络通信
不同机器的通过网络相互通信，要遵循相同的网络协议，也即TCP/IP网络协议栈。Linux 内核里有对于网络协议栈的实现

## 中介与Glibc
Glibc是 Linux 下使用的开源的标准 C 库，它是 GNU 发布的 libc 库。**Glibc 为程序员提供丰富的 API，除了例如字符串处理、数学运算等用户态服务之外，最重要的是封装了操作系统提供的系统服务，即系统调用的封装**。

## 总结
!["总结"](/pictures/05.jpg)
